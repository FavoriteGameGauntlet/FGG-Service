// Code generated by ogen, DO NOT EDIT.

package points

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ChangeOwnExperiencePoints invokes changeOwnExperiencePoints operation.
	//
	// POST /points/self/experience-points
	ChangeOwnExperiencePoints(ctx context.Context, request OptPointChange) (ChangeOwnExperiencePointsRes, error)
	// ChangeOwnFreePoints invokes changeOwnFreePoints operation.
	//
	// POST /points/self/free-points
	ChangeOwnFreePoints(ctx context.Context, request OptPointChange) (ChangeOwnFreePointsRes, error)
	// ChangeOwnTerritoryHours invokes changeOwnTerritoryHours operation.
	//
	// POST /points/self/territory-hours
	ChangeOwnTerritoryHours(ctx context.Context, request OptPointChange) (ChangeOwnTerritoryHoursRes, error)
	// ChangeOwnTerritoryPoints invokes changeOwnTerritoryPoints operation.
	//
	// POST /points/self/territory-points
	ChangeOwnTerritoryPoints(ctx context.Context, request OptPointChange) (ChangeOwnTerritoryPointsRes, error)
	// GetFreePointHistoryByLogin invokes getFreePointHistoryByLogin operation.
	//
	// GET /points/{login}/free-points/history
	GetFreePointHistoryByLogin(ctx context.Context, params GetFreePointHistoryByLoginParams) (GetFreePointHistoryByLoginRes, error)
	// GetOwnExperiencePoints invokes getOwnExperiencePoints operation.
	//
	// GET /points/self/experience-points
	GetOwnExperiencePoints(ctx context.Context) (GetOwnExperiencePointsRes, error)
	// GetOwnFreePointHistory invokes getOwnFreePointHistory operation.
	//
	// GET /points/self/free-points/history
	GetOwnFreePointHistory(ctx context.Context) (GetOwnFreePointHistoryRes, error)
	// GetOwnFreePoints invokes getOwnFreePoints operation.
	//
	// GET /points/self/free-points
	GetOwnFreePoints(ctx context.Context) (GetOwnFreePointsRes, error)
	// GetOwnPointInfo invokes getOwnPointInfo operation.
	//
	// GET /points/self/info
	GetOwnPointInfo(ctx context.Context) (GetOwnPointInfoRes, error)
	// GetOwnTerritoryHours invokes getOwnTerritoryHours operation.
	//
	// GET /points/self/territory-hours
	GetOwnTerritoryHours(ctx context.Context) (GetOwnTerritoryHoursRes, error)
	// GetOwnTerritoryPointHistory invokes getOwnTerritoryPointHistory operation.
	//
	// GET /points/self/territory-points/history
	GetOwnTerritoryPointHistory(ctx context.Context) (GetOwnTerritoryPointHistoryRes, error)
	// GetOwnTerritoryPoints invokes getOwnTerritoryPoints operation.
	//
	// GET /points/self/territory-points
	GetOwnTerritoryPoints(ctx context.Context) (GetOwnTerritoryPointsRes, error)
	// GetPointInfoByLogin invokes getPointInfoByLogin operation.
	//
	// GET /points/{login}/info
	GetPointInfoByLogin(ctx context.Context, params GetPointInfoByLoginParams) (GetPointInfoByLoginRes, error)
	// GetTerritoryPointHistoryByLogin invokes getTerritoryPointHistoryByLogin operation.
	//
	// GET /points/{login}/territory-points/history
	GetTerritoryPointHistoryByLogin(ctx context.Context, params GetTerritoryPointHistoryByLoginParams) (GetTerritoryPointHistoryByLoginRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// ChangeOwnExperiencePoints invokes changeOwnExperiencePoints operation.
//
// POST /points/self/experience-points
func (c *Client) ChangeOwnExperiencePoints(ctx context.Context, request OptPointChange) (ChangeOwnExperiencePointsRes, error) {
	res, err := c.sendChangeOwnExperiencePoints(ctx, request)
	return res, err
}

func (c *Client) sendChangeOwnExperiencePoints(ctx context.Context, request OptPointChange) (res ChangeOwnExperiencePointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("changeOwnExperiencePoints"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/points/self/experience-points"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChangeOwnExperiencePointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/experience-points"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeOwnExperiencePointsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChangeOwnExperiencePointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeOwnFreePoints invokes changeOwnFreePoints operation.
//
// POST /points/self/free-points
func (c *Client) ChangeOwnFreePoints(ctx context.Context, request OptPointChange) (ChangeOwnFreePointsRes, error) {
	res, err := c.sendChangeOwnFreePoints(ctx, request)
	return res, err
}

func (c *Client) sendChangeOwnFreePoints(ctx context.Context, request OptPointChange) (res ChangeOwnFreePointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("changeOwnFreePoints"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/points/self/free-points"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChangeOwnFreePointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/free-points"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeOwnFreePointsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChangeOwnFreePointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeOwnTerritoryHours invokes changeOwnTerritoryHours operation.
//
// POST /points/self/territory-hours
func (c *Client) ChangeOwnTerritoryHours(ctx context.Context, request OptPointChange) (ChangeOwnTerritoryHoursRes, error) {
	res, err := c.sendChangeOwnTerritoryHours(ctx, request)
	return res, err
}

func (c *Client) sendChangeOwnTerritoryHours(ctx context.Context, request OptPointChange) (res ChangeOwnTerritoryHoursRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("changeOwnTerritoryHours"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/points/self/territory-hours"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChangeOwnTerritoryHoursOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/territory-hours"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeOwnTerritoryHoursRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChangeOwnTerritoryHoursResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeOwnTerritoryPoints invokes changeOwnTerritoryPoints operation.
//
// POST /points/self/territory-points
func (c *Client) ChangeOwnTerritoryPoints(ctx context.Context, request OptPointChange) (ChangeOwnTerritoryPointsRes, error) {
	res, err := c.sendChangeOwnTerritoryPoints(ctx, request)
	return res, err
}

func (c *Client) sendChangeOwnTerritoryPoints(ctx context.Context, request OptPointChange) (res ChangeOwnTerritoryPointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("changeOwnTerritoryPoints"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/points/self/territory-points"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChangeOwnTerritoryPointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/territory-points"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeOwnTerritoryPointsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChangeOwnTerritoryPointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFreePointHistoryByLogin invokes getFreePointHistoryByLogin operation.
//
// GET /points/{login}/free-points/history
func (c *Client) GetFreePointHistoryByLogin(ctx context.Context, params GetFreePointHistoryByLoginParams) (GetFreePointHistoryByLoginRes, error) {
	res, err := c.sendGetFreePointHistoryByLogin(ctx, params)
	return res, err
}

func (c *Client) sendGetFreePointHistoryByLogin(ctx context.Context, params GetFreePointHistoryByLoginParams) (res GetFreePointHistoryByLoginRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFreePointHistoryByLogin"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/{login}/free-points/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetFreePointHistoryByLoginOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/points/"
	{
		// Encode "login" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "login",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.Login); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/free-points/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetFreePointHistoryByLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnExperiencePoints invokes getOwnExperiencePoints operation.
//
// GET /points/self/experience-points
func (c *Client) GetOwnExperiencePoints(ctx context.Context) (GetOwnExperiencePointsRes, error) {
	res, err := c.sendGetOwnExperiencePoints(ctx)
	return res, err
}

func (c *Client) sendGetOwnExperiencePoints(ctx context.Context) (res GetOwnExperiencePointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnExperiencePoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/experience-points"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnExperiencePointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/experience-points"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnExperiencePointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnFreePointHistory invokes getOwnFreePointHistory operation.
//
// GET /points/self/free-points/history
func (c *Client) GetOwnFreePointHistory(ctx context.Context) (GetOwnFreePointHistoryRes, error) {
	res, err := c.sendGetOwnFreePointHistory(ctx)
	return res, err
}

func (c *Client) sendGetOwnFreePointHistory(ctx context.Context) (res GetOwnFreePointHistoryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnFreePointHistory"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/free-points/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnFreePointHistoryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/free-points/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnFreePointHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnFreePoints invokes getOwnFreePoints operation.
//
// GET /points/self/free-points
func (c *Client) GetOwnFreePoints(ctx context.Context) (GetOwnFreePointsRes, error) {
	res, err := c.sendGetOwnFreePoints(ctx)
	return res, err
}

func (c *Client) sendGetOwnFreePoints(ctx context.Context) (res GetOwnFreePointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnFreePoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/free-points"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnFreePointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/free-points"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnFreePointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnPointInfo invokes getOwnPointInfo operation.
//
// GET /points/self/info
func (c *Client) GetOwnPointInfo(ctx context.Context) (GetOwnPointInfoRes, error) {
	res, err := c.sendGetOwnPointInfo(ctx)
	return res, err
}

func (c *Client) sendGetOwnPointInfo(ctx context.Context) (res GetOwnPointInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnPointInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/info"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnPointInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnPointInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnTerritoryHours invokes getOwnTerritoryHours operation.
//
// GET /points/self/territory-hours
func (c *Client) GetOwnTerritoryHours(ctx context.Context) (GetOwnTerritoryHoursRes, error) {
	res, err := c.sendGetOwnTerritoryHours(ctx)
	return res, err
}

func (c *Client) sendGetOwnTerritoryHours(ctx context.Context) (res GetOwnTerritoryHoursRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnTerritoryHours"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/territory-hours"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnTerritoryHoursOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/territory-hours"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnTerritoryHoursResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnTerritoryPointHistory invokes getOwnTerritoryPointHistory operation.
//
// GET /points/self/territory-points/history
func (c *Client) GetOwnTerritoryPointHistory(ctx context.Context) (GetOwnTerritoryPointHistoryRes, error) {
	res, err := c.sendGetOwnTerritoryPointHistory(ctx)
	return res, err
}

func (c *Client) sendGetOwnTerritoryPointHistory(ctx context.Context) (res GetOwnTerritoryPointHistoryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnTerritoryPointHistory"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/territory-points/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnTerritoryPointHistoryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/territory-points/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnTerritoryPointHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOwnTerritoryPoints invokes getOwnTerritoryPoints operation.
//
// GET /points/self/territory-points
func (c *Client) GetOwnTerritoryPoints(ctx context.Context) (GetOwnTerritoryPointsRes, error) {
	res, err := c.sendGetOwnTerritoryPoints(ctx)
	return res, err
}

func (c *Client) sendGetOwnTerritoryPoints(ctx context.Context) (res GetOwnTerritoryPointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOwnTerritoryPoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/self/territory-points"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOwnTerritoryPointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/points/self/territory-points"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOwnTerritoryPointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPointInfoByLogin invokes getPointInfoByLogin operation.
//
// GET /points/{login}/info
func (c *Client) GetPointInfoByLogin(ctx context.Context, params GetPointInfoByLoginParams) (GetPointInfoByLoginRes, error) {
	res, err := c.sendGetPointInfoByLogin(ctx, params)
	return res, err
}

func (c *Client) sendGetPointInfoByLogin(ctx context.Context, params GetPointInfoByLoginParams) (res GetPointInfoByLoginRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPointInfoByLogin"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/{login}/info"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPointInfoByLoginOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/points/"
	{
		// Encode "login" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "login",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.Login); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPointInfoByLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTerritoryPointHistoryByLogin invokes getTerritoryPointHistoryByLogin operation.
//
// GET /points/{login}/territory-points/history
func (c *Client) GetTerritoryPointHistoryByLogin(ctx context.Context, params GetTerritoryPointHistoryByLoginParams) (GetTerritoryPointHistoryByLoginRes, error) {
	res, err := c.sendGetTerritoryPointHistoryByLogin(ctx, params)
	return res, err
}

func (c *Client) sendGetTerritoryPointHistoryByLogin(ctx context.Context, params GetTerritoryPointHistoryByLoginParams) (res GetTerritoryPointHistoryByLoginRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTerritoryPointHistoryByLogin"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/points/{login}/territory-points/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTerritoryPointHistoryByLoginOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/points/"
	{
		// Encode "login" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "login",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.Login); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/territory-points/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTerritoryPointHistoryByLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
