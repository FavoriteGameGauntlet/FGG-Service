// Code generated by ogen, DO NOT EDIT.

package wheel_effects

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes ApplyAvailableWheelEffectRollConflict as json.
func (s *ApplyAvailableWheelEffectRollConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplyAvailableWheelEffectRollConflict from json.
func (s *ApplyAvailableWheelEffectRollConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyAvailableWheelEffectRollConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyAvailableWheelEffectRollConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyAvailableWheelEffectRollConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyAvailableWheelEffectRollConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyAvailableWheelEffectRollInternalServerError as json.
func (s *ApplyAvailableWheelEffectRollInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplyAvailableWheelEffectRollInternalServerError from json.
func (s *ApplyAvailableWheelEffectRollInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyAvailableWheelEffectRollInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyAvailableWheelEffectRollInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyAvailableWheelEffectRollInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyAvailableWheelEffectRollInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyAvailableWheelEffectRollNotFound as json.
func (s *ApplyAvailableWheelEffectRollNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplyAvailableWheelEffectRollNotFound from json.
func (s *ApplyAvailableWheelEffectRollNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyAvailableWheelEffectRollNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyAvailableWheelEffectRollNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyAvailableWheelEffectRollNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyAvailableWheelEffectRollNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyAvailableWheelEffectRollUnauthorized as json.
func (s *ApplyAvailableWheelEffectRollUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplyAvailableWheelEffectRollUnauthorized from json.
func (s *ApplyAvailableWheelEffectRollUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyAvailableWheelEffectRollUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyAvailableWheelEffectRollUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyAvailableWheelEffectRollUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyAvailableWheelEffectRollUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FreePointChangeResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FreePointChangeResult) encodeFields(e *jx.Encoder) {
	{
		if s.ChangeSource.Set {
			e.FieldStart("changeSource")
			s.ChangeSource.Encode(e)
		}
	}
	{
		if s.ChangeValue.Set {
			e.FieldStart("changeValue")
			s.ChangeValue.Encode(e)
		}
	}
	{
		e.FieldStart("actualChangeValue")
		e.Int(s.ActualChangeValue)
	}
	{
		e.FieldStart("finalValue")
		s.FinalValue.Encode(e)
	}
	{
		e.FieldStart("changeDate")
		json.EncodeDateTime(e, s.ChangeDate)
	}
	{
		if s.WheelEffectName.Set {
			e.FieldStart("wheelEffectName")
			s.WheelEffectName.Encode(e)
		}
	}
}

var jsonFieldsNameOfFreePointChangeResult = [6]string{
	0: "changeSource",
	1: "changeValue",
	2: "actualChangeValue",
	3: "finalValue",
	4: "changeDate",
	5: "wheelEffectName",
}

// Decode decodes FreePointChangeResult from json.
func (s *FreePointChangeResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreePointChangeResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "changeSource":
			if err := func() error {
				s.ChangeSource.Reset()
				if err := s.ChangeSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changeSource\"")
			}
		case "changeValue":
			if err := func() error {
				s.ChangeValue.Reset()
				if err := s.ChangeValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changeValue\"")
			}
		case "actualChangeValue":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ActualChangeValue = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actualChangeValue\"")
			}
		case "finalValue":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FinalValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalValue\"")
			}
		case "changeDate":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ChangeDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changeDate\"")
			}
		case "wheelEffectName":
			if err := func() error {
				s.WheelEffectName.Reset()
				if err := s.WheelEffectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wheelEffectName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FreePointChangeResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFreePointChangeResult) {
					name = jsonFieldsNameOfFreePointChangeResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FreePointChangeResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreePointChangeResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FreePointChangeResultChangeSource as json.
func (s FreePointChangeResultChangeSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FreePointChangeResultChangeSource from json.
func (s *FreePointChangeResultChangeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreePointChangeResultChangeSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FreePointChangeResultChangeSource(v) {
	case FreePointChangeResultChangeSourceOwnWheelEffect:
		*s = FreePointChangeResultChangeSourceOwnWheelEffect
	case FreePointChangeResultChangeSourceOtherWheelEffect:
		*s = FreePointChangeResultChangeSourceOtherWheelEffect
	case FreePointChangeResultChangeSourceQuest:
		*s = FreePointChangeResultChangeSourceQuest
	case FreePointChangeResultChangeSourceBaseTeleport:
		*s = FreePointChangeResultChangeSourceBaseTeleport
	case FreePointChangeResultChangeSourceSandstorm:
		*s = FreePointChangeResultChangeSourceSandstorm
	case FreePointChangeResultChangeSourceOther:
		*s = FreePointChangeResultChangeSourceOther
	default:
		*s = FreePointChangeResultChangeSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FreePointChangeResultChangeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreePointChangeResultChangeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FreePointChangeResults as json.
func (s FreePointChangeResults) Encode(e *jx.Encoder) {
	unwrapped := []FreePointChangeResult(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes FreePointChangeResults from json.
func (s *FreePointChangeResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreePointChangeResults to nil")
	}
	var unwrapped []FreePointChangeResult
	if err := func() error {
		unwrapped = make([]FreePointChangeResult, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem FreePointChangeResult
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FreePointChangeResults(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FreePointChangeResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreePointChangeResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAvailableWheelEffectRollsCountInternalServerError as json.
func (s *GetAvailableWheelEffectRollsCountInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAvailableWheelEffectRollsCountInternalServerError from json.
func (s *GetAvailableWheelEffectRollsCountInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAvailableWheelEffectRollsCountInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAvailableWheelEffectRollsCountInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAvailableWheelEffectRollsCountInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAvailableWheelEffectRollsCountInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAvailableWheelEffectRollsCountNotFound as json.
func (s *GetAvailableWheelEffectRollsCountNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAvailableWheelEffectRollsCountNotFound from json.
func (s *GetAvailableWheelEffectRollsCountNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAvailableWheelEffectRollsCountNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAvailableWheelEffectRollsCountNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAvailableWheelEffectRollsCountNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAvailableWheelEffectRollsCountNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAvailableWheelEffectRollsCountUnauthorized as json.
func (s *GetAvailableWheelEffectRollsCountUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAvailableWheelEffectRollsCountUnauthorized from json.
func (s *GetAvailableWheelEffectRollsCountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAvailableWheelEffectRollsCountUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAvailableWheelEffectRollsCountUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAvailableWheelEffectRollsCountUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAvailableWheelEffectRollsCountUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOwnAvailableWheelEffectsInternalServerError as json.
func (s *GetOwnAvailableWheelEffectsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOwnAvailableWheelEffectsInternalServerError from json.
func (s *GetOwnAvailableWheelEffectsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOwnAvailableWheelEffectsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOwnAvailableWheelEffectsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOwnAvailableWheelEffectsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOwnAvailableWheelEffectsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOwnAvailableWheelEffectsUnauthorized as json.
func (s *GetOwnAvailableWheelEffectsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOwnAvailableWheelEffectsUnauthorized from json.
func (s *GetOwnAvailableWheelEffectsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOwnAvailableWheelEffectsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOwnAvailableWheelEffectsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOwnAvailableWheelEffectsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOwnAvailableWheelEffectsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOwnWheelEffectHistoryInternalServerError as json.
func (s *GetOwnWheelEffectHistoryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOwnWheelEffectHistoryInternalServerError from json.
func (s *GetOwnWheelEffectHistoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOwnWheelEffectHistoryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOwnWheelEffectHistoryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOwnWheelEffectHistoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOwnWheelEffectHistoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOwnWheelEffectHistoryUnauthorized as json.
func (s *GetOwnWheelEffectHistoryUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOwnWheelEffectHistoryUnauthorized from json.
func (s *GetOwnWheelEffectHistoryUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOwnWheelEffectHistoryUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOwnWheelEffectHistoryUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOwnWheelEffectHistoryUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOwnWheelEffectHistoryUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWheelEffectHistoryByLoginInternalServerError as json.
func (s *GetWheelEffectHistoryByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWheelEffectHistoryByLoginInternalServerError from json.
func (s *GetWheelEffectHistoryByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWheelEffectHistoryByLoginInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWheelEffectHistoryByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWheelEffectHistoryByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWheelEffectHistoryByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWheelEffectHistoryByLoginNotFound as json.
func (s *GetWheelEffectHistoryByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWheelEffectHistoryByLoginNotFound from json.
func (s *GetWheelEffectHistoryByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWheelEffectHistoryByLoginNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWheelEffectHistoryByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWheelEffectHistoryByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWheelEffectHistoryByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWheelEffectHistoryByLoginUnauthorized as json.
func (s *GetWheelEffectHistoryByLoginUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWheelEffectHistoryByLoginUnauthorized from json.
func (s *GetWheelEffectHistoryByLoginUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWheelEffectHistoryByLoginUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWheelEffectHistoryByLoginUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWheelEffectHistoryByLoginUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWheelEffectHistoryByLoginUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Login as json.
func (s Login) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Login from json.
func (s *Login) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Login to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Login(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Login) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Login) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Name as json.
func (s Name) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Name from json.
func (s *Name) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Name to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Name(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Name) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Name) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FreePointChangeResultChangeSource as json.
func (o OptFreePointChangeResultChangeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FreePointChangeResultChangeSource from json.
func (o *OptFreePointChangeResultChangeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFreePointChangeResultChangeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFreePointChangeResultChangeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFreePointChangeResultChangeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Name as json.
func (o OptName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Name from json.
func (o *OptName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PointChange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PointChange) encodeFields(e *jx.Encoder) {
	{
		if s.ChangeSource.Set {
			e.FieldStart("changeSource")
			s.ChangeSource.Encode(e)
		}
	}
	{
		if s.ChangeValue.Set {
			e.FieldStart("changeValue")
			s.ChangeValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfPointChange = [2]string{
	0: "changeSource",
	1: "changeValue",
}

// Decode decodes PointChange from json.
func (s *PointChange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PointChange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "changeSource":
			if err := func() error {
				s.ChangeSource.Reset()
				if err := s.ChangeSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changeSource\"")
			}
		case "changeValue":
			if err := func() error {
				s.ChangeValue.Reset()
				if err := s.ChangeValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changeValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PointChange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PointChange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PointChange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PointChangeByLogin) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PointChangeByLogin) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	{
		e.FieldStart("pointChange")
		s.PointChange.Encode(e)
	}
}

var jsonFieldsNameOfPointChangeByLogin = [2]string{
	0: "login",
	1: "pointChange",
}

// Decode decodes PointChangeByLogin from json.
func (s *PointChangeByLogin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PointChangeByLogin to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "pointChange":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PointChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pointChange\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PointChangeByLogin")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPointChangeByLogin) {
					name = jsonFieldsNameOfPointChangeByLogin[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PointChangeByLogin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PointChangeByLogin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PointChangeByLogins as json.
func (s PointChangeByLogins) Encode(e *jx.Encoder) {
	unwrapped := []PointChangeByLogin(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes PointChangeByLogins from json.
func (s *PointChangeByLogins) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PointChangeByLogins to nil")
	}
	var unwrapped []PointChangeByLogin
	if err := func() error {
		unwrapped = make([]PointChangeByLogin, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PointChangeByLogin
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PointChangeByLogins(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PointChangeByLogins) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PointChangeByLogins) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Points as json.
func (s Points) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes Points from json.
func (s *Points) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Points to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Points(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Points) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Points) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollAvailableWheelEffectsConflict as json.
func (s *RollAvailableWheelEffectsConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollAvailableWheelEffectsConflict from json.
func (s *RollAvailableWheelEffectsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollAvailableWheelEffectsConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollAvailableWheelEffectsConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollAvailableWheelEffectsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollAvailableWheelEffectsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollAvailableWheelEffectsInternalServerError as json.
func (s *RollAvailableWheelEffectsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollAvailableWheelEffectsInternalServerError from json.
func (s *RollAvailableWheelEffectsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollAvailableWheelEffectsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollAvailableWheelEffectsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollAvailableWheelEffectsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollAvailableWheelEffectsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollAvailableWheelEffectsNotFound as json.
func (s *RollAvailableWheelEffectsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollAvailableWheelEffectsNotFound from json.
func (s *RollAvailableWheelEffectsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollAvailableWheelEffectsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollAvailableWheelEffectsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollAvailableWheelEffectsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollAvailableWheelEffectsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollAvailableWheelEffectsUnauthorized as json.
func (s *RollAvailableWheelEffectsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollAvailableWheelEffectsUnauthorized from json.
func (s *RollAvailableWheelEffectsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollAvailableWheelEffectsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollAvailableWheelEffectsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollAvailableWheelEffectsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollAvailableWheelEffectsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RolledWheelEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RolledWheelEffect) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		e.FieldStart("rollDate")
		json.EncodeDateTime(e, s.RollDate)
	}
}

var jsonFieldsNameOfRolledWheelEffect = [4]string{
	0: "name",
	1: "description",
	2: "position",
	3: "rollDate",
}

// Decode decodes RolledWheelEffect from json.
func (s *RolledWheelEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RolledWheelEffect to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "rollDate":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.RollDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RolledWheelEffect")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRolledWheelEffect) {
					name = jsonFieldsNameOfRolledWheelEffect[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RolledWheelEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RolledWheelEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RolledWheelEffects as json.
func (s RolledWheelEffects) Encode(e *jx.Encoder) {
	unwrapped := []RolledWheelEffect(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes RolledWheelEffects from json.
func (s *RolledWheelEffects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RolledWheelEffects to nil")
	}
	var unwrapped []RolledWheelEffect
	if err := func() error {
		unwrapped = make([]RolledWheelEffect, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RolledWheelEffect
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RolledWheelEffects(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RolledWheelEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RolledWheelEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WheelEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WheelEffect) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfWheelEffect = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes WheelEffect from json.
func (s *WheelEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WheelEffect to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WheelEffect")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWheelEffect) {
					name = jsonFieldsNameOfWheelEffect[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WheelEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WheelEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WheelEffects as json.
func (s WheelEffects) Encode(e *jx.Encoder) {
	unwrapped := []WheelEffect(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes WheelEffects from json.
func (s *WheelEffects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WheelEffects to nil")
	}
	var unwrapped []WheelEffect
	if err := func() error {
		unwrapped = make([]WheelEffect, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem WheelEffect
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WheelEffects(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WheelEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WheelEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
