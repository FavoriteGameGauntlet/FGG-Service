// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"time"

	"github.com/labstack/echo/v4"
)

// Defines values for GameState.
const (
	GameStateCancelled GameState = "cancelled"
	GameStateFinished  GameState = "finished"
	GameStateStarted   GameState = "started"
)

// Defines values for TimerState.
const (
	TimerStateCreated  TimerState = "created"
	TimerStateFinished TimerState = "finished"
	TimerStatePaused   TimerState = "paused"
	TimerStateRunning  TimerState = "running"
)

// Defines values for TimerActionType.
const (
	Pause TimerActionType = "pause"
	Start TimerActionType = "start"
	Stop  TimerActionType = "stop"
)

// Effect defines model for Effect.
type Effect struct {
	Description *string `json:"description,omitempty"`
	Name        Name    `json:"name"`
}

// Effects defines model for Effects.
type Effects = []Effect

// Email defines model for Email.
type Email = string

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// Game defines model for Game.
type Game struct {
	FinishDate *time.Time `json:"finishDate,omitempty"`
	Name       Name       `json:"name"`
	State      GameState  `json:"state"`
	TimeSpent  string     `json:"timeSpent"`
}

// GameState defines model for Game.State.
type GameState string

// Games defines model for Games.
type Games = []Game

// Name defines model for Name.
type Name = string

// NewUser defines model for NewUser.
type NewUser struct {
	Email    Email    `json:"email"`
	Name     Name     `json:"name"`
	Password Password `json:"password"`
}

// Password defines model for Password.
type Password = string

// RolledEffect defines model for RolledEffect.
type RolledEffect struct {
	Description *string   `json:"description,omitempty"`
	Name        Name      `json:"name"`
	RollDate    time.Time `json:"rollDate"`
}

// RolledEffects defines model for RolledEffects.
type RolledEffects = []RolledEffect

// Timer defines model for Timer.
type Timer struct {
	DurationInS      int        `json:"durationInS"`
	RemainingTimeInS int        `json:"remainingTimeInS"`
	State            TimerState `json:"state"`
	TimerActionDate  *time.Time `json:"timerActionDate,omitempty"`
}

// TimerState defines model for Timer.State.
type TimerState string

// TimerAction defines model for TimerAction.
type TimerAction struct {
	RemainingTimeInS int             `json:"remainingTimeInS"`
	Type             TimerActionType `json:"type"`
}

// TimerActionType defines model for TimerAction.Type.
type TimerActionType string

// UnplayedGame defines model for UnplayedGame.
type UnplayedGame struct {
	Name Name `json:"name"`
}

// UnplayedGames defines model for UnplayedGames.
type UnplayedGames = []UnplayedGame

// User defines model for User.
type User struct {
	Name     Name     `json:"name"`
	Password Password `json:"password"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = User

// SignUpJSONRequestBody defines body for SignUp for application/json ContentType.
type SignUpJSONRequestBody = NewUser

// AddUnplayedGamesJSONRequestBody defines body for AddUnplayedGames for application/json ContentType.
type AddUnplayedGamesJSONRequestBody = UnplayedGames

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Log in an existing user
	// (POST /auth/login)
	Login(ctx echo.Context) error
	// Log out the current user
	// (POST /auth/logout)
	Logout(ctx echo.Context) error
	// Register a new user account
	// (POST /auth/signup)
	SignUp(ctx echo.Context) error
	// Get a list of effects available for rolling
	// (POST /effects/available)
	GetAvailableEffects(ctx echo.Context) error
	// Check if there are any effect rolls available
	// (GET /effects/has-roll)
	CheckAvailableEffectRoll(ctx echo.Context) error
	// Get a list of all effect rolls
	// (GET /effects/history)
	GetEffectHistory(ctx echo.Context) error
	// Make the roll of the effect available
	// (POST /effects/roll)
	MakeEffectRoll(ctx echo.Context) error
	// Get the current game
	// (GET /games/current)
	GetCurrentGame(ctx echo.Context) error
	// Cancel the current game
	// (POST /games/current/cancel)
	CancelCurrentGame(ctx echo.Context) error
	// Complete the current game
	// (POST /games/current/finish)
	FinishCurrentGame(ctx echo.Context) error
	// Get a list of all games played
	// (GET /games/history)
	GetGameHistory(ctx echo.Context) error
	// Select a random game from the wishlist
	// (POST /games/roll)
	MakeGameRoll(ctx echo.Context) error
	// Get game wishlist
	// (GET /games/unplayed)
	GetUnplayedGames(ctx echo.Context) error
	// Add game wishlist
	// (POST /games/unplayed)
	AddUnplayedGames(ctx echo.Context) error
	// Get a timer for the current game
	// (GET /timers/current)
	GetCurrentTimer(ctx echo.Context) error
	// Pause the current timer
	// (POST /timers/current/pause)
	PauseCurrentTimer(ctx echo.Context) error
	// Start or continue the current timer
	// (POST /timers/current/start)
	StartCurrentTimer(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// SignUp converts echo context to params.
func (w *ServerInterfaceWrapper) SignUp(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SignUp(ctx)
	return err
}

// GetAvailableEffects converts echo context to params.
func (w *ServerInterfaceWrapper) GetAvailableEffects(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAvailableEffects(ctx)
	return err
}

// CheckAvailableEffectRoll converts echo context to params.
func (w *ServerInterfaceWrapper) CheckAvailableEffectRoll(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CheckAvailableEffectRoll(ctx)
	return err
}

// GetEffectHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetEffectHistory(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEffectHistory(ctx)
	return err
}

// MakeEffectRoll converts echo context to params.
func (w *ServerInterfaceWrapper) MakeEffectRoll(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MakeEffectRoll(ctx)
	return err
}

// GetCurrentGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentGame(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentGame(ctx)
	return err
}

// CancelCurrentGame converts echo context to params.
func (w *ServerInterfaceWrapper) CancelCurrentGame(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CancelCurrentGame(ctx)
	return err
}

// FinishCurrentGame converts echo context to params.
func (w *ServerInterfaceWrapper) FinishCurrentGame(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FinishCurrentGame(ctx)
	return err
}

// GetGameHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameHistory(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameHistory(ctx)
	return err
}

// MakeGameRoll converts echo context to params.
func (w *ServerInterfaceWrapper) MakeGameRoll(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MakeGameRoll(ctx)
	return err
}

// GetUnplayedGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetUnplayedGames(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUnplayedGames(ctx)
	return err
}

// AddUnplayedGames converts echo context to params.
func (w *ServerInterfaceWrapper) AddUnplayedGames(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddUnplayedGames(ctx)
	return err
}

// GetCurrentTimer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentTimer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentTimer(ctx)
	return err
}

// PauseCurrentTimer converts echo context to params.
func (w *ServerInterfaceWrapper) PauseCurrentTimer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PauseCurrentTimer(ctx)
	return err
}

// StartCurrentTimer converts echo context to params.
func (w *ServerInterfaceWrapper) StartCurrentTimer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartCurrentTimer(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/auth/login", wrapper.Login)
	router.POST(baseURL+"/auth/logout", wrapper.Logout)
	router.POST(baseURL+"/auth/signup", wrapper.SignUp)
	router.POST(baseURL+"/effects/available", wrapper.GetAvailableEffects)
	router.GET(baseURL+"/effects/has-roll", wrapper.CheckAvailableEffectRoll)
	router.GET(baseURL+"/effects/history", wrapper.GetEffectHistory)
	router.POST(baseURL+"/effects/roll", wrapper.MakeEffectRoll)
	router.GET(baseURL+"/games/current", wrapper.GetCurrentGame)
	router.POST(baseURL+"/games/current/cancel", wrapper.CancelCurrentGame)
	router.POST(baseURL+"/games/current/finish", wrapper.FinishCurrentGame)
	router.GET(baseURL+"/games/history", wrapper.GetGameHistory)
	router.POST(baseURL+"/games/roll", wrapper.MakeGameRoll)
	router.GET(baseURL+"/games/unplayed", wrapper.GetUnplayedGames)
	router.POST(baseURL+"/games/unplayed", wrapper.AddUnplayedGames)
	router.GET(baseURL+"/timers/current", wrapper.GetCurrentTimer)
	router.POST(baseURL+"/timers/current/pause", wrapper.PauseCurrentTimer)
	router.POST(baseURL+"/timers/current/start", wrapper.StartCurrentTimer)

}
